# Логирование

Одна из ключевых особенностей библиотеки, это наличие логов, которые помогают понять, что происходило в библиотеки, и самое главное предупреждают о возможных проблемах и указывают на ошибки.

## Настройка
По умолчанию логи выводятся функцией print которая выглядит следующим образом:
```Swift
print("\(logLevel): \(message)")
```
Она выводит уровень логирования, и сообщение. 
> Логирование в библиотеки сделано синхронным, поэтому в релизе стоит отключать логи, и не стоит усложнять сильно функцию логирования.

Для того чтобы задать свою функцию логирование, надо обратится к настройкам:
```Swift
DISetting.Log.fun = { level, message in
    NSLog("[\(level)]: \(message)")
}
```
Так как логи могут выводить процесс создания объектов, а объекты создаются вложено, то для удобства чтения библиотека добавляет табуляцию в сообщение. По умолчанию знаком табуляции является символ таба, но его можно заменить на любой другой:
```Swift
DISetting.Log.tab = ">>"
```

## Уровни логирования
Всего есть 4 уровня логирования: 
* error - ошибка. Если вы увидели в логах подобный уровень, значит, программа или уже упала или может упасть в дальнейшем с большой долей вероятности.
* warning - предупреждение. Оно предупреждает о проблемах, но не гарантирует, что они будут. 
* info - информация. Логи информируют о том что, что-то пошло по нежелательному сценарию, но при этом ничему плохого не произойдет.
* verbose - спам :) Логи для описания того что происходит в библиотеки, во время её использования. Нужны для отладки библиотеки, а также в случаи сложных графом зависимости.

И 5 уровень вспомогательный уровень `none` - он полностью отключает логи.

Для того чтобы задать какой уровень логов вы хотите видеть нужно указать один из 5 уровней. Это будет означать, что будут видны все логи до этого уровня включительно. Приоритет логов следующий: `none < error < warning < info < verbose`. Для их задания используется следующий синтаксис:
```Swift
DISetting.Log.level = .verbose
```
По умолчанию стоит уровень логирования `info`

### Описание логов
#### fatal error

* `Can't cast {obj} to optional {type}. For more information see logs.` - В идеале такой ошибки не должно возникать. Если программа упала с такой ошибкой, возможно, стоит включить полные логи, и обратится к автору библиотеки приложив логи.
* `Can't resolve type {type}. For more information see logs.` - Не удалось создать объект для указанного типа. Тип при этом не опциональный. Скорей всего это означает, что указанный тип не зарегистрирован, или во время его создания есть серьезные проблемы. Обычно в логах перед этим будет подсказка, что именно прошло не так.
* `Registration with type found {type}, but the registration return nil. See {Component}` - библиотека смогла создать объект, но метод создания объекта вернул nil. Такое возможно только если прикладной код зарегистрировал опциональное создание, но при этом есть место, где этот объект внедряется не опционально. По логам можно найти куда внедрялся этот компонент.
* `Registration with type found {type}, but the registration return nil.` - Аналог предыдущего, только в этом случае библиотека не смогла понять на каком компоненте произошла проблема. В этом случае надо смотреть логи.
* `Can't cast {objtype} to {type}. For more information see logs.` - Такая ошибка может возникнуть при не верном использовании библиотечной функции `as`. Поэтому стоит посмотреть для типа объекта посмотреть, что написано в регистрации.
* `"Please inject this property from DI in file: {file} on line: {line}. ...`  Такая ошибка возникает если вы используется Lazy или Provider инициализируете их пустыми, и при этом потом не заменяет их на аналог из DI контейнера - то есть отсутствует  внедрение этих свойств.  

#### error логи

* `Until get argument. Not found extensions for {Component}` - во время получения аргумента оказалось, что его нет. Такая ситуация возможна когда в указанном компоненте есть `arg`, но во время создания объекта аргумент не был передан с помощью возможностей библиотеки. Подробно про аргументы тут: [Модификаторы внедрения](modificated_injection.md#Аргумент)
* `Until make extensions can't find component by type: {type} in file: {file} on line: {line}` - при добавление расширения, не удалось найти компонент для указанного типа. На текущий момент такое возможно, только если вы хотите указать передачу компонентов. Для решение проблемы убедить что в контейнере зарегистрирован компонент данного типа.
* `Until make extensions can't choose component by type: {type} in file: {file} on line: {line}` - аналог выше стоящему, но только в этом случае говорится что для указанного типа выбор большой, и библиотека не может определиться какой выбрать. Для решения проблемы нужно убрать лишние регистрации.
* `Are you using root components, but a root component was found that was not marked as root: {Component}` - Может возникаеть в случае если вы используете на проекте root компоненты, но при этом был найден такой корневой resolve, который пытается создать не root компонент. Возможно такое возникло из-за не правильного использования, или же просто вы забыли объявить компонент рутовым. Обращаю внимание, что возникновение данной ошибки не гарантирует дальнейшей корректной работы библиотеки, так-как валидация графа была только с помеченными root компонентами.

#### info логи
* `Not found {type}` - не удалось найти компонент для указанного типа. Очень часто после этой ошибки следующая приведет к фатальной, так как тип окажется не опциональным.

#### verbose логи
Эти логи являются очень полезные для отладки, но их много, и описывать в данном файле не вижу необходимости. Они содержат информацию о том, что объект был зарегистрирован, что объект начал/закончил создаваться, объект начали получать, объект был создан.

### Логи при валидации графа
По мимо описанных логов, также есть логи которые пишутся во время проверки графа. Подробней о процедуре проверки графа, и возможных сообщениях можно почитать [тут](../graph/graph_validation.md) 
